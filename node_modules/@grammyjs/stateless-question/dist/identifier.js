const URL_TEXT = '\u200C';
const BASE_URL = 'http://t.me/#';
const URL_SEPERATOR = '#';
export function isContextReplyToMessage(context) {
    return Boolean(context.message?.reply_to_message);
}
function getRelevantEntity(context) {
    const repliedTo = context.message.reply_to_message;
    const entities = repliedTo.entities
        ?? repliedTo.caption_entities
        ?? [];
    const relevantEntity = entities
        .slice(-1)
        .find((o) => o.type === 'text_link');
    return relevantEntity;
}
export function isReplyToQuestion(context, identifier) {
    const relevantEntity = getRelevantEntity(context);
    const expectedUrl = url(identifier, undefined);
    return Boolean(relevantEntity?.url.startsWith(expectedUrl));
}
export function getAdditionalState(context, identifier) {
    const relevantEntity = getRelevantEntity(context);
    const expectedUrl = url(identifier, undefined);
    const part = relevantEntity.url.slice(expectedUrl.length);
    return decodeURIComponent(part);
}
function url(identifier, additionalState) {
    return BASE_URL + identifier + URL_SEPERATOR
        + encodeURIComponent(additionalState ?? '');
}
const MARKDOWN_PREFIX = `[${URL_TEXT}](`;
export function suffixMarkdown(identifier, additionalState) {
    const part = url(identifier, additionalState);
    if (part.includes(')')) {
        throw new Error('Markdown does not work with a stateless-question identifier or additionalState containing a close bracket `)`. Use MarkdownV2 or HTML.');
    }
    return MARKDOWN_PREFIX + part + ')';
}
export function suffixMarkdownV2(identifier, additionalState) {
    // eslint-disable-next-line unicorn/prefer-string-replace-all
    const part = url(identifier, additionalState).replace(/\)/g, '\\)');
    return MARKDOWN_PREFIX + part + ')';
}
const HTML_SUFFIX = `">${URL_TEXT}</a>`;
export function suffixHTML(identifier, additionalState) {
    return '<a href="' + url(identifier, additionalState) + HTML_SUFFIX;
}
